/**
 * sessions.js - Session Store (Memory or Redis)
 *
 * ANONYMITY GUARANTEE:
 * - Sessions live only in memory (process RAM or Redis RAM).
 * - No disk writes, no persistence required.
 * - Session IDs are never logged or persisted.
 */

const { REDIS_URL, getRedisClient } = require('./redisClient');

const SESSION_TTL_MS = 30 * 60 * 1000; // 30 minutes max session lifetime
const CLEANUP_INTERVAL_MS = 60 * 1000; // Sweep every 60 seconds

const USE_REDIS = !!REDIS_URL;
const sessions = new Map();
let expireHandler = null;

const KEYS = {
  session: (id) => `sess:${id}`,
  sessionBySocket: (sid) => `sessBySocket:${sid}`,
  createdZ: 'sess:created',
};

/**
 * Register a new anonymous session.
 * @param {string} sessionId - UUID v4 generated by the client
 * @param {string} socketId - Socket.IO socket ID
 */
async function addSession(sessionId, socketId) {
  const createdAt = Date.now();
  if (!USE_REDIS) {
    sessions.set(sessionId, { socketId, roomId: null, createdAt });
    return;
  }

  const client = await getRedisClient();
  const data = { socketId, roomId: null, createdAt };
  await client.set(KEYS.session(sessionId), JSON.stringify(data));
  await client.set(KEYS.sessionBySocket(socketId), sessionId);
  await client.zAdd(KEYS.createdZ, [{ score: createdAt, value: sessionId }]);
}

/**
 * Remove a session permanently from memory.
 * After this call, no trace of the session exists.
 */
async function removeSession(sessionId) {
  if (!USE_REDIS) {
    sessions.delete(sessionId);
    return;
  }

  const client = await getRedisClient();
  const raw = await client.get(KEYS.session(sessionId));
  const data = raw ? JSON.parse(raw) : null;
  const multi = client.multi();
  multi.del(KEYS.session(sessionId));
  multi.zRem(KEYS.createdZ, sessionId);
  if (data?.socketId) {
    multi.del(KEYS.sessionBySocket(data.socketId));
  }
  await multi.exec();
}

/**
 * Get session data. Returns undefined if session doesn't exist.
 */
async function getSession(sessionId) {
  if (!USE_REDIS) {
    return sessions.get(sessionId);
  }
  const client = await getRedisClient();
  const raw = await client.get(KEYS.session(sessionId));
  return raw ? JSON.parse(raw) : null;
}

/**
 * Assign a room to a session.
 */
async function setSessionRoom(sessionId, roomId) {
  if (!USE_REDIS) {
    const session = sessions.get(sessionId);
    if (session) session.roomId = roomId;
    return;
  }

  const client = await getRedisClient();
  const raw = await client.get(KEYS.session(sessionId));
  if (!raw) return;
  const data = JSON.parse(raw);
  data.roomId = roomId;
  await client.set(KEYS.session(sessionId), JSON.stringify(data));
}

/**
 * Clear room assignment from a session.
 */
async function clearSessionRoom(sessionId) {
  if (!USE_REDIS) {
    const session = sessions.get(sessionId);
    if (session) session.roomId = null;
    return;
  }

  const client = await getRedisClient();
  const raw = await client.get(KEYS.session(sessionId));
  if (!raw) return;
  const data = JSON.parse(raw);
  data.roomId = null;
  await client.set(KEYS.session(sessionId), JSON.stringify(data));
}

/**
 * Find session ID by socket ID.
 */
async function getSessionBySocketId(socketId) {
  if (!USE_REDIS) {
    for (const [sessionId, data] of sessions) {
      if (data.socketId === socketId) return sessionId;
    }
    return null;
  }

  const client = await getRedisClient();
  return await client.get(KEYS.sessionBySocket(socketId));
}

/**
 * Get total active session count (for health checks only).
 */
async function getSessionCount() {
  if (!USE_REDIS) {
    return sessions.size;
  }
  const client = await getRedisClient();
  return await client.zCard(KEYS.createdZ);
}

/**
 * TTL cleanup - removes expired sessions.
 * This ensures no session lingers in memory beyond its TTL.
 */
async function cleanupExpiredSessions() {
  const now = Date.now();

  if (!USE_REDIS) {
    const expired = [];
    for (const [sessionId, data] of sessions) {
      if (now - data.createdAt > SESSION_TTL_MS) {
        expired.push({ sessionId, socketId: data.socketId, roomId: data.roomId });
        sessions.delete(sessionId);
      }
    }
    if (expired.length && typeof expireHandler === 'function') {
      await expireHandler(expired);
    }
    return expired;
  }

  const client = await getRedisClient();
  const threshold = now - SESSION_TTL_MS;
  const expiredIds = await client.zRangeByScore(KEYS.createdZ, 0, threshold);
  if (!expiredIds.length) return [];

  const rawList = await client.mGet(expiredIds.map((id) => KEYS.session(id)));
  const expired = [];
  for (let i = 0; i < expiredIds.length; i++) {
    const raw = rawList[i];
    if (raw) {
      const data = JSON.parse(raw);
      expired.push({ sessionId: expiredIds[i], socketId: data.socketId, roomId: data.roomId });
    } else {
      expired.push({ sessionId: expiredIds[i], socketId: null, roomId: null });
    }
  }

  const multi = client.multi();
  for (const id of expiredIds) {
    multi.del(KEYS.session(id));
    multi.zRem(KEYS.createdZ, id);
  }
  for (const entry of expired) {
    if (entry.socketId) multi.del(KEYS.sessionBySocket(entry.socketId));
  }
  await multi.exec();

  if (expired.length && typeof expireHandler === 'function') {
    await expireHandler(expired);
  }
  return expired;
}

// Start periodic cleanup
const cleanupTimer = setInterval(() => {
  cleanupExpiredSessions().catch((err) => {
    console.error('Session cleanup error:', err?.message || err);
  });
}, CLEANUP_INTERVAL_MS);
// Allow Node.js to exit even if timer is running
cleanupTimer.unref();

/**
 * Register a handler for expired sessions.
 * The handler receives an array of { sessionId, socketId, roomId }.
 */
function setExpireHandler(fn) {
  expireHandler = fn;
}

module.exports = {
  addSession,
  removeSession,
  getSession,
  setSessionRoom,
  clearSessionRoom,
  getSessionBySocketId,
  getSessionCount,
  cleanupExpiredSessions,
  setExpireHandler,
};
